import { store } from '../store.js'

// util
import { equalItemRanked } from './equalItemRanked.js'
import { flatten } from './flatten.js'
import { head } from './head.js'
import { splice } from './splice.js'
import { getContextsSortedAndRanked } from './getContextsSortedAndRanked.js'

/** Merges items into a context chain, removing the overlapping head */
// use autogenerated rank of context
// if there is no/empty context chain, return itemsRanked as-is
export const chain = (contextChain, itemsRanked, data = store.getState().data) => {

  if (!contextChain || contextChain.length === 0) return itemsRanked

  const pivot = head(contextChain[contextChain.length - 1])
  const i = itemsRanked.findIndex(child => equalItemRanked(child, pivot))
  const append = itemsRanked.slice(i - 1)
  const contexts = getContextsSortedAndRanked(pivot.key, data)
  const appendedItemInContext = contexts.find(child => head(child.context) === append[0].key)

  return flatten(
    // keep the first segment intact
    // then remove the overlapping head of each one after
    contextChain.concat([
      appendedItemInContext
        ? [{ key: append[0].key, rank: appendedItemInContext.rank }].concat(append.slice(1))
        : append
    ]).map((items, i) => i > 0 ? splice(items, 1, 1) : items)
  )
}
// assert.deepEqual(chain(
//   [
//     [{ key: 'a', rank: 0 }, { key: 'b', rank: 0 }]
//   ],
//   [{ key: 'a', rank: 0 }, { key: 'b', rank: 0 }, { key: 'c', rank: 0 }],
// ), [{ key: 'a', rank: 0 }, { key: 'b', rank: 0 }, { key: 'a', rank: 0 }, { key: 'c', rank: 0 }])

// assert.deepEqual(unrank(chain(
//   [
//     rankItemsSequential(['2', 'A']),
//     rankItemsSequential(['1', 'A', 'Nope']),
//   ],
//   rankItemsSequential(['START', 'B', 'Nope', 'Butter', 'Bread'])
// )), ['2', 'A', '1', 'Nope', 'B', 'Butter', 'Bread'])
