import { store } from '../store.js'
import globals from '../globals.js'
import { tutorialNext } from '../action-creators/tutorial.js'

// constants
import {
  RANKED_ROOT,
  RENDER_DELAY,
  TUTORIAL_STEP_FIRSTTHOUGHT,
  TUTORIAL_STEP_SECONDTHOUGHT,
  TUTORIAL_STEP_SUBTHOUGHT,
  TUTORIAL2_STEP_CONTEXT1_PARENT,
  TUTORIAL2_STEP_CONTEXT1_PARENT_HINT,
  TUTORIAL2_STEP_CONTEXT1,
  TUTORIAL2_STEP_CONTEXT1_HINT,
  TUTORIAL2_STEP_CONTEXT2_PARENT,
  TUTORIAL2_STEP_CONTEXT2_PARENT_HINT,
  TUTORIAL2_STEP_CONTEXT2,
  TUTORIAL2_STEP_CONTEXT2_HINT,
} from '../constants.js'

// util
import { asyncFocus } from './asyncFocus.js'
import { unrank } from './unrank.js'
import { isContextViewActive } from './isContextViewActive.js'
import { intersections } from './intersections.js'
import { splitChain } from './splitChain.js'
import { lastItemsFromContextChain } from './lastItemsFromContextChain.js'
import { unroot } from './unroot.js'
import { getRankBefore } from './getRankBefore.js'
import { getRankAfter } from './getRankAfter.js'
import { getPrevRank } from './getPrevRank.js'
import { getNextRank } from './getNextRank.js'
import { restoreSelection } from './restoreSelection.js'

/** Adds a new item to the cursor.
 * @param offset The focusOffset of the selection in the new item. Defaults to end.
*/
// NOOP if the cursor is not set
export const newItem = ({ at, insertNewChild, insertBefore, value = '', offset } = {}) => {

  const state = store.getState()
  const tutorialStep = state.settings.tutorialStep
  const tutorialStepNewThoughtCompleted =
    // new thought
    (!insertNewChild && (
      Math.floor(tutorialStep) === TUTORIAL_STEP_FIRSTTHOUGHT ||
      Math.floor(tutorialStep) === TUTORIAL_STEP_SECONDTHOUGHT
    )) ||
    // new thought in context
    (insertNewChild && Math.floor(tutorialStep) === TUTORIAL_STEP_SUBTHOUGHT)

  const path = at || state.cursor || RANKED_ROOT
  const dispatch = store.dispatch

  const contextChain = splitChain(path, state.contextViews)
  const showContexts = isContextViewActive(unrank(path), { state })
  const showContextsParent = isContextViewActive(unrank(intersections(path)), { state })
  const itemsRanked = contextChain.length > 1
    ? lastItemsFromContextChain(contextChain)
    : path
  const contextRanked = showContextsParent && contextChain.length > 1 ? contextChain[contextChain.length - 2]
    : !showContextsParent && itemsRanked.length > 1 ? intersections(itemsRanked) :
    RANKED_ROOT
  const context = unrank(contextRanked)

  // use the live-edited value
  // const itemsLive = showContextsParent
  //   ? intersections(intersections(items)).concat().concat(signifier(items))
  //   : items
  // const itemsRankedLive = showContextsParent
  //   ? intersections(intersections(path).concat({ key: innerTextRef, rank })).concat(signifier(path))
  //   : path

  // if meta key is pressed, add a child instead of a sibling of the current thought
  // if shift key is pressed, insert the child before the current thought
  const newRank = (showContextsParent && !insertNewChild) || (showContexts && insertNewChild) ? 0 // rank does not matter here since it is autogenerated
    : (insertBefore
        ? (insertNewChild || !path ? getPrevRank : getRankBefore)
        : (insertNewChild || !path ? getNextRank : getRankAfter)
      )(itemsRanked)

  dispatch({
    type: 'newItemSubmit',
    context: insertNewChild
      ? unrank(itemsRanked)
      : context,
    // inserting a new child into a context functions the same as in the normal item view
    addAsContext: (showContextsParent && !insertNewChild) || (showContexts && insertNewChild),
    rank: newRank,
    value
  })

  // tutorial step 1
  if (tutorialStepNewThoughtCompleted) {
    tutorialNext()
  }
  // some hints are rolled back when a new item is created
  else if (tutorialStep === TUTORIAL2_STEP_CONTEXT1_PARENT_HINT) {
    dispatch({ type: 'tutorialStep', value: TUTORIAL2_STEP_CONTEXT1_PARENT })
  }
  else if (tutorialStep === TUTORIAL2_STEP_CONTEXT1_HINT) {
    dispatch({ type: 'tutorialStep', value: TUTORIAL2_STEP_CONTEXT1 })
  }
  else if (tutorialStep === TUTORIAL2_STEP_CONTEXT2_PARENT_HINT) {
    dispatch({ type: 'tutorialStep', value: TUTORIAL2_STEP_CONTEXT2_PARENT })
  }
  else if (tutorialStep === TUTORIAL2_STEP_CONTEXT2_HINT) {
    dispatch({ type: 'tutorialStep', value: TUTORIAL2_STEP_CONTEXT2 })
  }

  globals.disableOnFocus = true
  asyncFocus.enable()
  setTimeout(() => {
    // track the transcendental identifier if editing
    globals.disableOnFocus = false
    restoreSelection((insertNewChild ? unroot(path) : intersections(path)).concat({ key: value, rank: newRank }), { offset: offset != null ? offset : value.length })
  }, RENDER_DELAY)

  return {
    rank: newRank
  }
}
